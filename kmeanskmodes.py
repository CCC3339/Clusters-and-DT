# -*- coding: utf-8 -*-
"""KmeansKmodes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16ejorEdnZb6q_q83Id-0e1pDXN3rMG4v
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
from google.colab import drive
import seaborn as sns
from sklearn.preprocessing import LabelEncoder,MinMaxScaler, StandardScaler
from sklearn.cluster import DBSCAN , KMeans 
import math
import graphviz
!pip install kmodes
from kmodes.kmodes import KModes

path="/content/drive/MyDrive/SISTEMAS INTELIGENTES/Datasets/nypd_DANGER.csv"
NYPD = pd.read_csv(path)
ny=NYPD.copy()
bor="/content/drive/MyDrive/SISTEMAS INTELIGENTES/Datasets/nypd_boro.csv"
BORO = pd.read_csv(bor)
des="/content/drive/MyDrive/SISTEMAS INTELIGENTES/Datasets/nypd_decision.csv"
DESI = pd.read_csv(des)

BORO=BORO.replace(to_replace=["BROOKLYN","MANHATTAN","BRONX","QUEENS","STATEN ISLAND"],value=["2","1","4","3","5"])
BORO["borough"].value_counts()

NYPD["danger"].value_counts()

kmeans = KMeans(n_clusters=4)
nyclusters = kmeans.fit(NYPD)
NYPD["Cluster"] = kmeans.fit_predict(NYPD)
NYPD["Cluster"] = NYPD["Cluster"].astype("category")
dangerlevel = kmeans.labels_[3]

kmeanSs = KMeans(n_clusters=5)
BORO["Cluster"] = kmeanSs.fit_predict(BORO)
BORO["Cluster"] = BORO["Cluster"].astype("category")
BoroZone = kmeanSs.labels_[5]
BORO

sns.relplot(x="longitude", y="latitude", hue="Cluster", data=BORO, height=5,);

sns.relplot(x="longitude", y="latitude", hue="Cluster", data=NYPD, height=5,);

DESI.head()

# Elbow curve to find optimal K
cost = []
K = range(1,5)
for num_clusters in list(K):
    kmode = KModes(n_clusters=num_clusters, init = "random", n_init = 5, verbose=1)
    kmode.fit_predict(DESI)
    cost.append(kmode.cost_)
    
plt.plot(K, cost, 'bx-')
plt.xlabel('No. of clusters')
plt.ylabel('Cost')
plt.title('Elbow Method For Optimal k')
plt.show()

# Building the model with 3 clusters
kmode = KModes(n_clusters=3, init = "random", n_init = 5, verbose=1)
clusters = kmode.fit_predict(DESI)
clusters

DESI.insert(0, "Cluster", clusters, True)
DESI

for col in DESI:
    plt.subplots(figsize = (15,5))
    sns.countplot(x='Cluster',hue=col, data = DESI)
    plt.show()